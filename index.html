<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Ø¢Ù„Ø© Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ (Ø³/Øµ) â€“ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©</title>
  <style>
    :root{
      /* Ø¯Ø§ÙƒÙ† (Ø§ÙØªØ±Ø§Ø¶ÙŠ) */
      --bg:#0b1220; --panel:#0f172a; --panel-2:#111827; --text:#e5e7eb;
      --muted:#9fb2c9; --grid-sub:#162133; --grid:#20314b; --axis:#93c5fd;
      --accent:#22d3ee; --danger:#ef4444; --ok:#22c55e; --warn:#f59e0b;
      --chip:#0b1422; --border:#172133; --shadow:0 1px 0 #0c111b, inset 0 1px 0 rgba(255,255,255,.02);
      --sidebar-w:380px; --z-drawer:20; --z-fab:15; --z-status:10;
    }
    :root.light{
      /* ÙØ§ØªØ­ */
      --bg:#f8fafc; --panel:#ffffff; --panel-2:#f3f4f6; --text:#0f172a;
      --muted:#475569; --grid-sub:#e5e7eb; --grid:#cbd5e1; --axis:#1f2937;
      --accent:#0ea5e9; --danger:#dc2626; --ok:#16a34a; --warn:#d97706;
      --chip:#eef2ff; --border:#e5e7eb; --shadow:0 1px 0 #e5e7eb, inset 0 1px 0 rgba(0,0,0,.02);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Arabic",Arial,"Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }

    .app{display:grid; grid-template-columns: var(--sidebar-w) 1fr; height:100%}
    .sidebar{background:linear-gradient(180deg,var(--panel),var(--panel-2)); border-left:1px solid var(--border); padding:14px; overflow:auto; position:relative}
    .header{display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; margin-bottom:8px}
    h1{font-size:18px; margin:0; font-weight:800}
    .muted{color:var(--muted); font-size:12px}
    .toolbar{display:flex; flex-wrap:wrap; gap:8px; margin:10px 0 12px}
    .btn{background:transparent; color:var(--text); border:1px solid var(--border); padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px; box-shadow:var(--shadow)}
    .btn:hover{filter:brightness(1.05)}
    .btn.primary{background:var(--chip)}
    .btn.ok{color:#0f5132; background:rgba(34,197,94,.15); border-color:rgba(34,197,94,.35)}
    .btn.warn{color:#7c2d12; background:rgba(245,158,11,.15); border-color:rgba(245,158,11,.35)}
    .btn.danger{color:#7f1d1d; background:rgba(239,68,68,.15); border-color:rgba(239,68,68,.35)}
    .hint{font-size:12px; color:var(--muted); line-height:1.7}
    .badge{padding:2px 8px; border-radius:999px; border:1px solid var(--border); background:var(--chip)}
    .expr-list,.slider-list{display:grid; gap:10px}
    .card{background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:10px; box-shadow:var(--shadow)}
    .expr-card{display:grid; grid-template-columns:28px 1fr auto; gap:8px; align-items:center}
    .input{width:100%; background:var(--panel-2); border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:10px; font-size:14px; outline:none}
    .mini{display:flex; gap:6px; align-items:center}
    .icon-btn{background:transparent; border:0; color:var(--muted); cursor:pointer; font-size:16px}
    .icon-btn:hover{color:var(--danger)}
    .colorpick{appearance:none; -webkit-appearance:none; background:transparent; border:0; width:24px; height:24px; padding:0; cursor:pointer}
    .lw{width:110px}
    .lw-label{font-size:12px; color:var(--muted); min-width:36px; text-align:center}

    .canvas-wrap{position:relative; background:radial-gradient(1200px 600px at 100% 0%, rgba(34,211,238,.04), transparent 60%)}
    canvas{display:block; width:100%; height:100%; background:transparent}

    .status{position:absolute; bottom:8px; left:10px; z-index:var(--z-status); background:rgba(2,6,23,.55); border:1px solid var(--border); border-radius:10px; padding:6px 10px; font-size:12px; color:#cbd5e1; backdrop-filter:blur(4px)}
    .light .status{background:rgba(255,255,255,.75); color:#0f172a; border-color:#cbd5e1}

    .floating{position:absolute; top:8px; left:12px; display:flex; gap:6px; z-index:var(--z-fab)}
    .fab{background:var(--panel); border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:10px; cursor:pointer; font-size:13px}

    .drawer-toggle{position:absolute; top:10px; right:10px; z-index:20; display:none; background:var(--panel); border:1px solid var(--border); color:var(--text); padding:6px 10px; border-radius:10px; cursor:pointer; font-size:13px}
    @media (max-width:900px){
      .app{grid-template-columns:1fr}
      .sidebar{position:absolute; inset:0 auto 0 0; width:min(100vw, var(--sidebar-w)); transform:translateX(-100%); transition:transform .25s ease; z-index:20; box-shadow:2px 0 18px rgba(0,0,0,.25)}
      .sidebar.open{transform:translateX(0)}
      .drawer-toggle{display:inline-block}
      .floating{left:auto; right:12px}
    }
  </style>
</head>
<body>
  <button id="btnDrawer" class="drawer-toggle">â˜° Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
  <div class="app" id="appRoot">
    <aside id="sidebar" class="sidebar">
      <div class="header">
        <div>
          <h1>Ø¢Ù„Ø© Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ (Ø³/Øµ) â€“ Ù…ÙˆØ³Ù‘Ø¹Ø©</h1>
          <div class="muted">Ù…Ù†Ø²Ù„Ù‚Ø§ØªØŒ Ù…Ø¬Ø§Ù„Ø§ØªØŒ Ø¶Ù…Ù†ÙŠ/Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠ/Ù‚Ø·Ø¨ÙŠØŒ ØªÙ‚Ø§Ø·Ø¹Ø§ØªØŒ Ù…Ù…Ø§Ø³ØŒ Ø­ÙØ¸/Ø§Ø³ØªÙŠØ±Ø§Ø¯ØŒ ÙˆØ¶Ø¹ ÙØ§ØªØ­/Ø¯Ø§ÙƒÙ†</div>
        </div>
        <div class="mini">
          <button id="btnTheme" class="btn" title="Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙØ§ØªØ­/Ø§Ù„Ø¯Ø§ÙƒÙ†">ğŸŒ“ ØªØ¨Ø¯ÙŠÙ„</button>
        </div>
      </div>

      <div class="toolbar">
        <button id="btnAdd" class="btn primary">+ Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø©</button>
        <button id="btnAddSlider" class="btn">+ Ù…Ù†Ø²Ù„Ù‚</button>
        <button id="btnExport" class="btn">ØªØµØ¯ÙŠØ± PNG</button>
        <button id="btnSave" class="btn ok">Ø­ÙØ¸ (JSON)</button>
        <button id="btnLoad" class="btn warn">Ø§Ø³ØªÙŠØ±Ø§Ø¯</button>
        <button id="btnShare" class="btn">Ù…Ø´Ø§Ø±ÙƒØ©</button>
      </div>

      <div class="hint">
        <b>ØµÙŠØº Ù…Ø¯Ø¹ÙˆÙ…Ø©:</b>
        <div>â€¢ ØµØ±ÙŠØ­Ø©: <span class="badge">Øµ = ØªØ¹Ø¨ÙŠØ±(Ø³)</span> Ø£Ùˆ <span class="badge">ØªØ¹Ø¨ÙŠØ±(Ø³) = Øµ</span></div>
        <div>â€¢ Ø®Ø·ÙŠØ© ÙÙŠ Øµ (ØªÙØ¹Ø²Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§): <span class="badge">Ø³ + Øµ = 4</span>ØŒ <span class="badge">2Ø³ + Øµ = 5</span></div>
        <div>â€¢ Ø¶Ù…Ù†ÙŠØ©: <span class="badge">Ø³^2 + Øµ^2 = 9</span>ØŒ <span class="badge">Ø³*Øµ = 1</span></div>
        <div>â€¢ Ø¨Ø§Ø±Ø§Ù…ØªØ±ÙŠØ©: <span class="badge">Ø³(t)=cos(t), Øµ(t)=sin(t) {0 â‰¤ t â‰¤ 2Ï€}</span></div>
        <div>â€¢ Ù‚Ø·Ø¨ÙŠØ©: <span class="badge">r(Î¸)=1+cos(Î¸) {0 â‰¤ Î¸ â‰¤ 2Ï€}</span></div>
        <div>â€¢ Ù…Ù†Ø²Ù„Ù‚Ø§Øª: <span class="badge">a, b, ...</span> ØªÙØ³ØªØ®Ø¯Ù… Ø¯Ø§Ø®Ù„ Ø§Ù„Ø¯ÙˆØ§Ù„.</div>
        Ø¯ÙˆØ§Ù„ Ø¹Ø±Ø¨ÙŠØ©: <span class="badge">Ø¬Ø§</span>ØŒ <span class="badge">Ø¬ØªØ§</span>ØŒ <span class="badge">Ø¸Ø§</span>ØŒ <span class="badge">Ø¬Ø°Ø±</span>ØŒ <span class="badge">Ù„Ù†</span>ØŒ <span class="badge">Ù„Ùˆ</span>.
      </div>

      <div class="section">
        <h3>Ø§Ù„Ø¯ÙˆØ§Ù„</h3>
        <div id="exprList" class="expr-list"></div>
        <div class="mini" style="margin-top:6px; color:var(--muted); font-size:12px">
          Ù„Ù„ØªØ¬Ø±ÙŠØ¨: Ø§Ø¶ØºØ· <b>Alt</b> Ø«Ù… Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ù…Ù†Ø­Ù†Ù‰ Ù„Ø¹Ø±Ø¶ <b>Ù…Ù…Ø§Ø³</b> ÙˆØ§Ù„Ù…ÙŠÙ„ Ø¹Ù†Ø¯ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø©.
        </div>
      </div>

      <div class="section">
        <h3>Ø§Ù„Ù…Ù†Ø²Ù„Ù‚Ø§Øª</h3>
        <div id="sliderList" class="slider-list"></div>
      </div>
    </aside>

    <main class="canvas-wrap">
      <div class="floating">
        <button id="btnZoomIn" class="fab">+ ØªÙƒØ¨ÙŠØ±</button>
        <button id="btnZoomOut" class="fab">âˆ’ ØªØµØºÙŠØ±</button>
        <button id="btnReset" class="fab">â†º Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¹Ø±Ø¶</button>
      </div>
      <canvas id="canvas"></canvas>
      <div id="status" class="status">Ø³ = 0, Øµ = 0 | Ù…Ù‚ÙŠØ§Ø³: 1u â‰ˆ 60px</div>
      <div id="tooltip" class="tooltip" style="display:none"></div>
      <input id="fileLoader" type="file" accept="application/json" style="display:none" />
    </main>
  </div>

<script>
(() => {
  /* ---------- Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© ---------- */
  const AR_DIGITS = "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©"; const EN_DIGITS = "0123456789";
  const toArabicDigits  = s => String(s).replace(/[0-9]/g, d => AR_DIGITS[d]);
  const toEnglishDigits = s => String(s).replace(/[Ù -Ù©]/g, ch => EN_DIGITS[AR_DIGITS.indexOf(ch)]).replace(/ØŒ/g, ',');
  const cssVar = name => getComputedStyle(document.documentElement).getPropertyValue(name);
  const uid   = () => Math.random().toString(36).slice(2,9);

  /* ---------- ØªØ­ÙˆÙŠÙ„ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¯ÙˆØ§Ù„ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ---------- */
  const arabicPairs = [
    [/\bØ¬Ø§\b/g,'sin'], [/\bØ¬ØªØ§\b/g,'cos'], [/\bØ¸Ø§\b/g,'tan'],
    [/\bØ¬Ø°Ø±\b/g,'sqrt'], [/\bÙ‚ÙŠÙ…Ø©_?Ù…Ø·Ù„Ù‚Ø©\b/g,'abs'],
    [/\bÙ„Ùˆ\b/g,'log'],   [/\bÙ„Ù†\b/g,'ln']
  ];

  /* ---------- Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ---------- */
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const tooltip  = document.getElementById('tooltip');
  const exprListEl   = document.getElementById('exprList');
  const sliderListEl = document.getElementById('sliderList');
  const sidebarEl    = document.getElementById('sidebar');

  const COLORS = ['#22d3ee','#a78bfa','#f472b6','#34d399','#f59e0b','#60a5fa','#ef4444','#10b981','#eab308','#06b6d4'];

  const state = {
    centerX:0, centerY:0, scale:60,
    dragging:false, dragStart:{x:0,y:0,cx:0,cy:0},
    mouse:{x:0,y:0,wx:0,wy:0},
    theme:'dark',
    expressions:[
      { id: uid(), color: COLORS[0], width: 2, text:'Øµ = Ø³^2', visible:true }
    ],
    sliders:[],
    polylines:[],
    touch:{active:false, lastDist:0, lastMid:null, lastTapTime:0, fingerCount:0}
  };

  /* ---------- ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù†Øµ + Ø§Ù„Ø¶Ø±Ø¨ Ø§Ù„Ø¶Ù…Ù†ÙŠ ---------- */
  function preprocessBasic(s){
    s = toEnglishDigits(String(s))
      .replace(/[Ø³x]/gi,'x').replace(/[Øµy]/gi,'y').replace(/[Î¸Ï´]/g,'theta')
      .replace(/Ï€|Ø¨Ø§ÙŠ/gi,'PI').replace(/Ù‡Ù€/g,'E')
      .replace(/[Ã·]/g,'/').replace(/[Ã—]/g,'*').replace(/\^/g,'**');

    arabicPairs.forEach(([re,rep]) => s = s.replace(re, rep));
    s = s.replace(/\bln\(/g,'log(');

    const FN='(sin|cos|tan|sqrt|abs|log)';
    s = s
      .replace(/(\d)\s*(x|y|theta|t|PI|E|\()/gi,'$1*$2')
      .replace(/(x|y|theta|t|PI|E|\))\s*(\d|\()/gi,'$1*$2')
      .replace(new RegExp(`(\\d|x|y|theta|t|PI|E)\\s*${FN}`,'gi'),'$1*$2')
      .replace(new RegExp(`\\)\\s*${FN}`,'gi'),')*$1')
      .replace(/\)\s*\(/g,')*(')
      .replace(/(x|y|theta|t)\s*(PI|E)/gi,'$1*$2')
      .replace(/(PI|E)\s*(x|y|theta|t)/gi,'$1*$2');

    return s.replace(/\s+/g,' ').trim();
  }
  const containsY = s => /\by\b/i.test(String(s));
  const sideIsY   = raw => /^y$/i.test(preprocessBasic(raw).trim());

  /* ---------- Ø¹Ø²Ù„ y Ø¬Ø¨Ø±ÙŠÙ‹Ø§ Ø¥Ù† ÙƒØ§Ù†Øª Ø®Ø·ÙŠØ© ---------- */
  function tryLinearSolveForY(lhsRaw, rhsRaw){
    const L0 = preprocessBasic(lhsRaw), R0 = preprocessBasic(rhsRaw);

    function solve(side, other){
      if (containsY(other)) return null;
      let m;
      // a*y Â± b
      m = side.match(/^(.+?)\*?y\s*([+\-])\s*(.+)$/i);
      if (m && !containsY(m[1]) && !containsY(m[3])) {
        const a=m[1].trim(), op=m[2], b=m[3].trim();
        const numer = (op==='+') ? `(${other})-(${b})` : `(${other})+(${b})`;
        return `(${numer})/(${a})`;
      }
      // y Â± b
      m = side.match(/^y\s*([+\-])\s*(.+)$/i);
      if (m && !containsY(m[2])) {
        const op=m[1], b=m[2].trim();
        return (op==='+') ? `(${other})-(${b})` : `(${other})+(${b})`;
      }
      // a*y
      m = side.match(/^(.+?)\*?y$/i);
      if (m && !containsY(m[1])) return `(${other})/(${m[1].trim()})`;
      // y
      if (/^y$/i.test(side)) return `${other}`;
      // other Â± y
      m = side.match(/^(.+)\s*([+\-])\s*y$/i);
      if (m && !containsY(m[1])) {
        const otherOnSide=m[1].trim(), op=m[2];
        return (op==='+') ? `(${other})-(${otherOnSide})` : `(${otherOnSide})-(${other})`;
      }
      // other Â± a*y
      m = side.match(/^(.+)\s*([+\-])\s*(.+?)\*?y$/i);
      if (m && !containsY(m[1]) && !containsY(m[3])) {
        const otherOnSide=m[1].trim(), op=m[2], a=m[3].trim();
        return (op==='+') ? `((${other})-(${otherOnSide}))/(${a})`
                          : `((${otherOnSide})-(${other}))/(${a})`;
      }
      return null;
    }

    let js = solve(R0, L0); if (js) return js;
    js = solve(L0, R0);    if (js) return js;
    return null;
  }

  /* ---------- Ù…Ø¬Ø§Ù„ {} ---------- */
  function extractDomain(raw){
    const m = raw.match(/\{([^}]*)\}/);
    if(!m) return {text: raw, domain: null};
    const inside = preprocessBasic(m[1]);
    let dom={xmin:null,xmax:null,ymin:null,ymax:null,tmin:null,tmax:null,thmin:null,thmax:null}, r;
    if(r=inside.match(/([\-+*/().,x0-9EPI ]*?)<=?x<=?([\-+*/().,x0-9EPI ]*?)/i)){ dom.xmin=r[1].trim(); dom.xmax=r[2].trim(); }
    else if(r=inside.match(/x\s*in\s*\[([^,]+),([^\]]+)\]/i)){ dom.xmin=r[1].trim(); dom.xmax=r[2].trim(); }
    if(r=inside.match(/([\-+*/().,x0-9EPI ]*?)<=?y<=?([\-+*/().,x0-9EPI ]*?)/i)){ dom.ymin=r[1].trim(); dom.ymax=r[2].trim(); }
    else if(r=inside.match(/y\s*in\s*\[([^,]+),([^\]]+)\]/i)){ dom.ymin=r[1].trim(); dom.ymax=r[2].trim(); }
    if(r=inside.match(/([\-+*/().,t0-9EPI ]*?)<=?t<=?([\-+*/().,t0-9EPI ]*?)/i)){ dom.tmin=r[1].trim(); dom.tmax=r[2].trim(); }
    else if(r=inside.match(/t\s*in\s*\[([^,]+),([^\]]+)\]/i)){ dom.tmin=r[1].trim(); dom.tmax=r[2].trim(); }
    if(r=inside.match(/([\-+*/().,0-9EPI ]*?)<=?(theta|Ï´|Î¸)<=?([\-+*/().,0-9EPI ]*?)/i)){ dom.thmin=r[1].trim(); dom.thmax=r[3].trim(); }
    else if(r=inside.match(/(theta|Ï´|Î¸)\s*in\s*\[([^,]+),([^\]]+)\]/i)){ dom.thmin=r[2].trim(); dom.thmax=r[3].trim(); }
    const cleaned = raw.replace(/\{[^}]*\}/,'').trim();
    return {text: cleaned, domain: dom};
  }

  /* ---------- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ÙˆØ¹ ---------- */
  function normalizeExpr(raw){
    if(!raw) return {kind:'none'};
    const {text, domain} = extractDomain(raw);
    let s = String(text).trim();
    const hasEq = s.includes('=');

    if (hasEq) {
      const [lhsRaw, rhsRaw] = s.split('=');
      const lhs = preprocessBasic(lhsRaw), rhs = preprocessBasic(rhsRaw);

      if (/x\(t\)\s*=/.test(lhs+rhs) && /y\(t\)\s*=/.test(lhs+rhs)) {
        const pair = preprocessBasic(s);
        const mx = pair.match(/x\(t\)\s*=\s*([^,;]+)[,;]/i);
        const my = pair.match(/y\(t\)\s*=\s*([^,;]+)/i);
        if (mx && my) return { kind:'param', xt: mx[1].trim(), yt: my[1].trim(), domain };
      }
      if (/r\((theta|Ï´|Î¸)\)\s*=/.test(lhs+rhs)) {
        const all = preprocessBasic(s);
        const mr = all.match(/r\((?:theta|Ï´|Î¸)\)\s*=\s*(.+)/i);
        if (mr) return { kind:'polar', rth: mr[1].trim(), domain };
      }
      if (sideIsY(lhs)) return { kind:'explicit', js: preprocessBasic(rhsRaw), domain };
      if (sideIsY(rhs)) return { kind:'explicit', js: preprocessBasic(lhsRaw), domain };

      const solved = tryLinearSolveForY(lhsRaw, rhsRaw);
      if (solved) return { kind:'explicit', js: preprocessBasic(solved), domain };

      return { kind:'implicit', eq: preprocessBasic(s), domain };
    }
    return { kind:'explicit', js: preprocessBasic(s), domain };
  }

  /* ---------- ØªÙ‚ÙŠÙŠÙ… Ø¯Ø§Ø®Ù„ Ù†Ø·Ø§Ù‚ Math + Ø§Ù„Ù…Ù†Ø²Ù„Ù‚Ø§Øª ---------- */
  const isSafe = expr => /^[0-9+\-*/().,\sxa-zA-Z_]*\**[0-9+\-*/().,\sxa-zA-Z_]*$/.test(expr);
  function buildScope(vars){
    const scope = Object.create(Math);
    scope.log10 = (v)=>Math.log10(v);
    scope.PI = Math.PI; scope.E = Math.E;
    for(const sl of state.sliders) scope[sl.name] = sl.value;
    if(vars) for(const k of Object.keys(vars)) scope[k] = vars[k];
    return scope;
  }
  function makeFn1(js){ if(!js||!isSafe(js)) throw new Error('ØªØ¹Ø¨ÙŠØ± ØºÙŠØ± ØµØ§Ù„Ø­'); return Function('x', `with(this){return (${js});}`).bind(buildScope()); }
  function makeFn2(js){ if(!js||!isSafe(js)) throw new Error('ØªØ¹Ø¨ÙŠØ± ØºÙŠØ± ØµØ§Ù„Ø­'); return Function('x','y', `with(this){return (${js});}`).bind(buildScope()); }
  function evalInScope(expr, extra){ const s=preprocessBasic(expr); return Function(`with(this){return (${s});}`).bind(buildScope(extra))(); }

  /* ---------- ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ---------- */
  function worldToScreen(x,y){ const r=devicePixelRatio||1,w=canvas.width,h=canvas.height; return { x:(w/2)+(x-state.centerX)*state.scale*r, y:(h/2)-(y-state.centerY)*state.scale*r }; }
  function screenToWorld(sx,sy){ const r=devicePixelRatio||1,w=canvas.width,h=canvas.height; return { x:(sx-w/2)/(state.scale*r)+state.centerX, y:-(sy-h/2)/(state.scale*r)+state.centerY }; }
  function resizeCanvas(){ const r=devicePixelRatio||1,rect=canvas.getBoundingClientRect(); canvas.width=Math.max(1,Math.floor(rect.width*r)); canvas.height=Math.max(1,Math.floor(rect.height*r)); draw(); }
  new ResizeObserver(resizeCanvas).observe(document.querySelector('.canvas-wrap'));

  /* ---------- Ø´Ø¨ÙƒØ© ÙˆÙ…Ø­Ø§ÙˆØ± ---------- */
  function niceStep(ppu){ const target=110, units=target/ppu, p=Math.pow(10, Math.floor(Math.log10(units))); const c=[1,2,5,10].map(v=>v*p); let best=c[0]; for(const v of c) if(Math.abs(v-units)<Math.abs(best-units)) best=v; return best; }
  function drawGrid(){
    const r=devicePixelRatio||1, w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = cssVar('--bg'); ctx.fillRect(0,0,w,h);

    const step = niceStep(state.scale), sub = step/5, tl=screenToWorld(0,0), br=screenToWorld(w,h);

    // ÙØ±Ø¹ÙŠØ©
    ctx.lineWidth=1; ctx.strokeStyle=cssVar('--grid-sub'); ctx.beginPath();
    for(let x=Math.floor(tl.x/sub)*sub;x<=br.x;x+=sub){ const sx=worldToScreen(x,0).x; ctx.moveTo(sx+.5,0); ctx.lineTo(sx+.5,h); }
    for(let y=Math.floor(br.y/sub)*sub;y<=tl.y;y+=sub){ const sy=worldToScreen(0,y).y; ctx.moveTo(0,sy+.5); ctx.lineTo(w,sy+.5); }
    ctx.stroke();

    // Ø±Ø¦ÙŠØ³ÙŠØ©
    ctx.strokeStyle=cssVar('--grid'); ctx.beginPath();
    for(let x=Math.floor(tl.x/step)*step;x<=br.x;x+=step){ const sx=worldToScreen(x,0).x; ctx.moveTo(sx+.5,0); ctx.lineTo(sx+.5,h); }
    for(let y=Math.floor(br.y/step)*step;y<=tl.y;y+=step){ const sy=worldToScreen(0,y).y; ctx.moveTo(0,sy+.5); ctx.lineTo(w,sy+.5); }
    ctx.stroke();

    // Ù…Ø­Ø§ÙˆØ±
    ctx.strokeStyle=cssVar('--axis'); ctx.lineWidth=1.5; ctx.beginPath();
    const sx0=worldToScreen(0,0).x, sy0=worldToScreen(0,0).y; ctx.moveTo(sx0+.5,0); ctx.lineTo(sx0+.5,h); ctx.moveTo(0,sy0+.5); ctx.lineTo(w,sy0+.5); ctx.stroke();

    // ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ù…Ø­Ø§ÙˆØ±
    ctx.fillStyle = cssVar('--axis');
    ctx.font = `${12*r}px system-ui, -apple-system, Segoe UI, Noto Sans Arabic, Arial`;
    ctx.textAlign='right'; ctx.textBaseline='top'; ctx.fillText('Ø³', Math.min(w-6,w-6), sy0 + 6);
    ctx.textAlign='left'; ctx.textBaseline='bottom'; ctx.fillText('Øµ', sx0 + 6, Math.max(12,12));

    // Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØªØ¯Ø±ÙŠØ¬
    ctx.fillStyle=cssVar('--muted');

    // (Ø£Ø±Ù‚Ø§Ù… Ù…Ø­ÙˆØ± Ø³) ØªØ¨Ù‚Ù‰ ØªØ­Øª Ø§Ù„Ù…Ø­ÙˆØ±
    ctx.textAlign='right'; ctx.textBaseline='top';
    for(let x=Math.floor(tl.x/step)*step;x<=br.x;x+=step){
      if(Math.abs(x)<1e-12) continue;
      const p=worldToScreen(x,0);
      ctx.fillText(toArabicDigits(x.toFixed(2).replace(/\.00$/,'')), p.x-4, sy0+6);
    }

    // (Ø£Ø±Ù‚Ø§Ù… Ù…Ø­ÙˆØ± Øµ) **Ø¥Ù„Ù‰ ÙŠØ³Ø§Ø±** Ø§Ù„Ù…Ø­ÙˆØ± Øµ
    ctx.textAlign='right'; ctx.textBaseline='bottom';
    for(let y=Math.floor(br.y/step)*step;y<=tl.y;y+=step){
      if(Math.abs(y)<1e-12) continue;
      const p=worldToScreen(0,y);
      ctx.fillText(toArabicDigits(y.toFixed(2).replace(/\.00$/,'')), sx0 - 6, p.y - 2);
    }
  }

  /* ---------- Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø­Ù†ÙŠØ§Øª ---------- */
  function adaptiveSampleX(f,left,right){
    const pts=[], maxDepth=12, eps=1e-2, N0=25;
    function rec(a,b,ya,yb,d){ const m=(a+b)/2; let ym=f(m); if(!isFinite(ya)) ya=f(a); if(!isFinite(yb)) yb=f(b);
      if(!isFinite(ym)||d>=maxDepth){ pts.push([a,ya],[b,yb]); return; }
      const ylin=(ya+yb)/2; if(Math.abs(ym-ylin)<eps*(1+Math.abs(ym))){ pts.push([a,ya],[b,yb]); return; }
      rec(a,m,ya,ym,d+1); rec(m,b,ym,yb,d+1);
    }
    let yL=f(left), yR=f(right);
    if(!isFinite(yL)||!isFinite(yR)){ const dx=(right-left)/N0; let x=left, lx=null, ly=null; for(let i=0;i<=N0;i++,x+=dx){ const y=f(x); if(isFinite(y)){ if(lx!==null){ rec(lx,x,ly,y,0); } lx=x; ly=y; } } }
    else rec(left,right,yL,yR,0);
    pts.sort((a,b)=>a[0]-b[0]); const out=[]; let prev=null; for(const p of pts){ if(!prev || p[0]!==prev[0]) out.push(p); prev=p; } return out;
  }

  function drawPolylines(){
    state.polylines.length=0;
    const r=devicePixelRatio||1, w=canvas.width, viewL=screenToWorld(0,0).x, viewR=screenToWorld(w,0).x;

    for(const [i,ex] of state.expressions.entries()){
      if(!ex.visible) continue;
      const spec = normalizeExpr(ex.text);
      const color = ex.color || COLORS[i%COLORS.length];
      const width = Math.max(0.5, Number(ex.width||2)) * r;

      let poly=[]; ctx.strokeStyle = color;

      try{
        if(spec.kind==='explicit'){
          const f = makeFn1(spec.js);
          let L=viewL, R=viewR;
          if(spec.domain && spec.domain.xmin) L = evalInScope(spec.domain.xmin);
          if(spec.domain && spec.domain.xmax) R = evalInScope(spec.domain.xmax);
          const pts = adaptiveSampleX(f, L, R);
          ctx.lineWidth = width; ctx.beginPath(); let pen=false;
          for(const [x,y] of pts){ const p=worldToScreen(x,y); if(!isFinite(p.x)||!isFinite(p.y)){ pen=false; continue; } if(!pen){ ctx.moveTo(p.x,p.y); pen=true; } else ctx.lineTo(p.x,p.y); poly.push([x,y]); }
          ctx.stroke();
        }
        else if(spec.kind==='implicit'){
          const tl=screenToWorld(0,0), br=screenToWorld(canvas.width, canvas.height);
          const nx=60, ny=40, dx=(br.x-tl.x)/nx, dy=(tl.y-br.y)/ny;
          const F = (()=>{ const eq=spec.eq.replace('=','-(')+')'; return makeFn2(eq); })();
          function val(x,y){ const v=F(x,y); return isFinite(v)?v:NaN; }
          ctx.lineWidth = width;
          for(let iy=0;iy<ny;iy++){
            for(let ix=0;ix<nx;ix++){
              const x0=tl.x+ix*dx, y0=tl.y-iy*dy, x1=x0+dx, y1=y0-dy;
              const v00=val(x0,y0), v10=val(x1,y0), v01=val(x0,y1), v11=val(x1,y1);
              const edges=[];
              function lerp(a,b,ta,tb){ const t=ta/(ta-tb); return a+(b-a)*t; }
              if(isFinite(v00)&&isFinite(v10)&&(v00>0)!=(v10>0)) edges.push([lerp(x0,x1,v00,v10),y0]);
              if(isFinite(v10)&&isFinite(v11)&&(v10>0)!=(v11>0)) edges.push([x1,lerp(y0,y1,v10,v11)]);
              if(isFinite(v01)&&isFinite(v11)&&(v01>0)!=(v11>0)) edges.push([lerp(x0,x1,v01,v11),y1]);
              if(isFinite(v00)&&isFinite(v01)&&(v00>0)!=(v01>0)) edges.push([x0,lerp(y0,y1,v00,v01)]);
              if(edges.length===2){ const p0=worldToScreen(edges[0][0],edges[0][1]), p1=worldToScreen(edges[1][0],edges[1][1]); ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke(); poly.push(edges[0],edges[1]); }
            }
          }
        }
        else if(spec.kind==='param'){
          const xt = Function('t', `with(this){return (${spec.xt});}`).bind(buildScope());
          const yt = Function('t', `with(this){return (${spec.yt});}`).bind(buildScope());
          let t0=0,t1=2*Math.PI; if(spec.domain){ if(spec.domain.tmin) t0=evalInScope(spec.domain.tmin,{t:0}); if(spec.domain.tmax) t1=evalInScope(spec.domain.tmax,{t:0}); }
          const steps=800, dt=(t1-t0)/steps; ctx.lineWidth=width; ctx.beginPath();
          for(let i=0;i<=steps;i++){ const t=t0+i*dt, x=xt(t), y=yt(t), p=worldToScreen(x,y); if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); poly.push([x,y]); }
          ctx.stroke();
        }
        else if(spec.kind==='polar'){
          const fr = Function('theta', `with(this){return (${spec.rth});}`).bind(buildScope());
          let th0=0, th1=2*Math.PI; if(spec.domain){ if(spec.domain.thmin) th0=evalInScope(spec.domain.thmin,{theta:0}); if(spec.domain.thmax) th1=evalInScope(spec.domain.thmax,{theta:0}); }
          const steps=800, d=(th1-th0)/steps; ctx.lineWidth=width; ctx.beginPath();
          for(let i=0;i<=steps;i++){ const th=th0+i*d, r0=fr(th), x=r0*Math.cos(th), y=r0*Math.sin(th), p=worldToScreen(x,y); if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); poly.push([x,y]); }
          ctx.stroke();
        }
      }catch(err){ markExprError(ex.id, err.message); continue; }

      clearExprError(ex.id);
      state.polylines.push({id:ex.id,color,points:poly});
    }
  }

  /* ---------- ØªÙ‚Ø§Ø·Ø¹Ø§Øª ØªÙ‚Ø±ÙŠØ¨ÙŠØ© ---------- */
  function segInter(p,q,r,s){
    function cross(a,b,c){ return (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0]); }
    const d=cross(p,q,r), e=cross(p,q,s), f=cross(r,s,p), g=cross(r,s,q);
    if((d===0&&e===0&&f===0&&g===0)) return null;
    if((d>0)!=(e>0) && (f>0)!=(g>0)){
      const A=q[0]-p[0], B=r[0]-s[0], C=q[1]-p[1], D=r[1]-s[1], E=r[0]-p[0], F=r[1]-p[1];
      const det=A*D-B*C; if(Math.abs(det)<1e-12) return null; const t=(E*D-B*F)/det; return [p[0]+t*A, p[1]+t*C];
    }
    return null;
  }
  function drawIntersections(){
    const dots=[];
    for(let i=0;i<state.polylines.length;i++){
      for(let j=i+1;j<state.polylines.length;j++){
        const A=state.polylines[i].points, B=state.polylines[j].points; if(A.length<2||B.length<2) continue;
        for(let a=1;a<A.length;a++){
          const a0=A[a-1], a1=A[a];
          for(let b=1;b<B.length;b++){
            const b0=B[b-1], b1=B[b];
            const P=segInter(a0,a1,b0,b1); if(P){ const sp=worldToScreen(P[0],P[1]); dots.push([sp.x,sp.y]); }
          }
        }
      }
    }
    ctx.fillStyle='#fef08a'; for(const d of dots){ ctx.beginPath(); ctx.arc(d[0],d[1], 4*(devicePixelRatio||1), 0, Math.PI*2); ctx.fill(); }
  }

  /* ---------- Ù…Ù…Ø§Ø³ (Alt+Click) ---------- */
  function drawTangentAt(xw,yw){
    let best=null, bestCurve=null, bestP=null;
    for(const pl of state.polylines){ for(const P of pl.points){ const d=(P[0]-xw)**2+(P[1]-yw)**2; if(best===null||d<best){ best=d; bestCurve=pl; bestP=P; } } }
    if(!bestCurve) return; if(!bestP) bestP=[xw,yw];
    const pts=bestCurve.points; let idx=pts.indexOf(bestP);
    if(idx<0){ idx=pts.reduce((bi,p,i)=>{ const d=(p[0]-bestP[0])**2+(p[1]-bestP[1])**2; const dbi=(pts[bi][0]-bestP[0])**2+(pts[bi][1]-bestP[1])**2; return d<dbi?i:bi; },0); }
    const i0=Math.max(0,idx-1), i1=Math.min(pts.length-1,idx+1); const dx=pts[i1][0]-pts[i0][0], dy=pts[i1][1]-pts[i0][1]; if(Math.abs(dx)+Math.abs(dy)<1e-12) return;
    const slope=dy/dx, len=4, xA=bestP[0]-len, yA=bestP[1]-slope*len, xB=bestP[0]+len, yB=bestP[1]+slope*len;
    const A=worldToScreen(xA,yA), B=worldToScreen(xB,yB), S=worldToScreen(bestP[0],bestP[1]);
    ctx.strokeStyle='#f87171'; ctx.lineWidth=2*(devicePixelRatio||1); ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    ctx.fillStyle='#fda4af'; ctx.beginPath(); ctx.arc(S.x,S.y, 4*(devicePixelRatio||1), 0, Math.PI*2); ctx.fill();
    showTooltip(S.x,S.y, `Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ø£Ù‚Ø±Ø¨â‰ˆ (Ø³=${bestP[0].toFixed(3)}, Øµ=${bestP[1].toFixed(3)}), Ø§Ù„Ù…ÙŠÙ„ mâ‰ˆ ${slope.toFixed(3)}`);
  }

  function draw(){ drawGrid(); drawPolylines(); drawIntersections(); updateStatus(); }

  /* ---------- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¯ÙˆØ§Ù„ (Ù„ÙˆÙ† + Ù…Ù†Ø²Ù„Ù‚ Ø³Ù…Ùƒ + Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø±Ø¨ÙŠ Ù„Ù„Ø£Ø±Ù‚Ø§Ù…) ---------- */
  function renderExprList(){
    exprListEl.innerHTML='';
    state.expressions.forEach((ex,idx)=>{
      const card=document.createElement('div'); card.className='card expr-card'; card.dataset.id=ex.id;

      // Ù…Ù†ØªÙ‚ÙŠ Ø§Ù„Ù„ÙˆÙ†
      const col=document.createElement('input'); col.type='color'; col.className='colorpick'; col.value=ex.color||COLORS[idx%COLORS.length];
      col.addEventListener('input',()=>{ ex.color=col.value; draw(); persistDeb(); });
      card.appendChild(col);

      // Ø­Ù‚Ù„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© (ØªØ­ÙˆÙŠÙ„ Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù…Ø¯Ø®Ù„ Ø¥Ù„Ù‰ Ø¹Ø±Ø¨ÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©)
      const inp=document.createElement('input'); inp.className='input';
      inp.placeholder='Ù…Ø«Ø§Ù„: Øµ = Ø³^2 | Ø³ + Øµ = 4 | 2Ø³ + Øµ = 5 | Ø³*Øµ = 1';
      inp.value=ex.text||'';
      // Ø¹Ù†Ø¯ Ø§Ù„ÙƒØªØ§Ø¨Ø©: Ø­ÙˆÙ‘ÙÙ„ Ø£ÙŠ Ø£Ø±Ù‚Ø§Ù… Ù„Ø§ØªÙŠÙ†ÙŠØ© Ø¥Ù„Ù‰ Ø¹Ø±Ø¨ÙŠØ© **ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶**
      inp.addEventListener('input', () => {
        const caretStart = inp.selectionStart, caretEnd = inp.selectionEnd;
        const before = inp.value;
        const converted = toArabicDigits(before);
        if (before !== converted) {
          inp.value = converted;
          // Ù†ÙØ³ Ø§Ù„Ø·ÙˆÙ„ â†’ Ù„Ø§ Ù†ØºÙŠÙ‘Ø± Ø§Ù„Ù…Ø¤Ø´Ø±
          inp.setSelectionRange(caretStart, caretEnd);
        }
        ex.text = inp.value; // Ù†Ø®Ø²Ù‘Ù† Ø§Ù„Ù†Øµ Ø¨ØµÙŠØºØªÙ‡ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©ØŒ ÙˆØ§Ù„Ù…ÙØ³Ù‘Ø± Ø³ÙŠØ­ÙˆÙ‘Ù„Ù‡ Ø¯Ø§Ø®Ù„ÙŠÙ‹Ø§ Ø¥Ù„Ù‰ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ Ù„Ù„ØªÙ‚ÙŠÙŠÙ…
        draw(); persistDeb();
      });
      card.appendChild(inp);

      // Ø£Ø¯ÙˆØ§Øª: Ù…Ù†Ø²Ù„Ù‚ Ø³Ù…Ùƒ + Ø¹Ø±Ø¶ Ù‚ÙŠÙ…ØªÙ‡ Ø¨Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© + Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡ + Ø­Ø°Ù
      const tools=document.createElement('div'); tools.className='mini';

      const lw=document.createElement('input'); lw.type='range'; lw.min='0.5'; lw.max='12'; lw.step='0.5'; lw.value=ex.width||2; lw.className='lw';
      const lwVal=document.createElement('span'); lwVal.className='lw-label'; lwVal.textContent=toArabicDigits((ex.width||2).toString());
      lw.addEventListener('input',()=>{ const v=Math.max(0.5, Math.min(12, parseFloat(lw.value)||2)); ex.width=v; lwVal.textContent=toArabicDigits(v.toString()); draw(); persistDeb(); });

      const vis=document.createElement('input'); vis.type='checkbox'; vis.checked=ex.visible!==false; vis.title='Ø¥Ø¸Ù‡Ø§Ø±/Ø¥Ø®ÙØ§Ø¡';
      vis.addEventListener('change',()=>{ ex.visible=vis.checked; draw(); persistDeb(); });

      const del=document.createElement('button'); del.className='icon-btn'; del.title='Ø­Ø°Ù'; del.textContent='ğŸ—‘ï¸';
      del.addEventListener('click',()=>{ state.expressions=state.expressions.filter(it=>it.id!==ex.id); renderExprList(); draw(); persistDeb(); });

      tools.appendChild(document.createTextNode('Ø³Ù…Ùƒ'));
      tools.appendChild(lw); tools.appendChild(lwVal);
      tools.appendChild(vis); tools.appendChild(del);
      card.appendChild(tools);

      exprListEl.appendChild(card);
    });
  }

  function markExprError(id,msg){ const card=exprListEl.querySelector(`[data-id="${id}"]`); if(card){ card.style.borderColor='#7f1d1d'; card.title=msg; } }
  function clearExprError(id){ const card=exprListEl.querySelector(`[data-id="${id}"]`); if(card){ card.style.borderColor='var(--border)'; card.title=''; } }

  /* ---------- Ø§Ù„Ù…Ù†Ø²Ù„Ù‚Ø§Øª ---------- */
  function renderSliders(){
    sliderListEl.innerHTML='';
    state.sliders.forEach((sl,idx)=>{
      const card=document.createElement('div'); card.className='card'; card.dataset.name=sl.name;

      const row=document.createElement('div'); row.className='mini'; row.style.gap='8px';
      const name=document.createElement('input'); name.className='input'; name.style.width='120px'; name.value=sl.name; name.title='Ø§Ø³Ù… Ø§Ù„Ù…ØªØºÙŠÙ‘Ø±';
      name.addEventListener('change',()=>{ sl.name=name.value.trim(); draw(); persistDeb(); });

      const range=document.createElement('input'); range.type='range'; range.min=sl.min; range.max=sl.max; range.step=sl.step; range.value=sl.value; range.style.flex='1';
      const val=document.createElement('span'); val.className='lw-label'; val.textContent=toArabicDigits(String(sl.value));
      range.addEventListener('input',()=>{ sl.value=parseFloat(range.value); val.textContent=toArabicDigits(String(sl.value)); draw(); persistDeb(); });

      const del=document.createElement('button'); del.className='btn danger'; del.textContent='Ø­Ø°Ù';
      del.onclick=()=>{ state.sliders.splice(idx,1); renderSliders(); draw(); persistDeb(); };

      row.appendChild(name); row.appendChild(range); row.appendChild(val); row.appendChild(del);
      const row2=document.createElement('div'); row2.className='mini'; row2.style.gap='6px';
      const lmin=document.createElement('input'); lmin.className='input'; lmin.style.width='80px'; lmin.value=sl.min;
      const lstep=document.createElement('input'); lstep.className='input'; lstep.style.width='80px'; lstep.value=sl.step;
      const lmax=document.createElement('input'); lmax.className='input'; lmax.style.width='80px'; lmax.value=sl.max;
      lmin.addEventListener('change',()=>{ sl.min=parseFloat(lmin.value)||sl.min; range.min=sl.min; });
      lstep.addEventListener('change',()=>{ sl.step=parseFloat(lstep.value)||sl.step; range.step=sl.step; });
      lmax.addEventListener('change',()=>{ sl.max=parseFloat(lmax.value)||sl.max; range.max=sl.max; });

      const hint=document.createElement('div'); hint.className='muted'; hint.textContent='Ø§Ù„Ù…Ø¯Ù‰: [Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ØŒ Ø§Ù„Ø®Ø·ÙˆØ©ØŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰]'; hint.style.marginTop='6px';

      card.appendChild(row); card.appendChild(row2);
      row2.appendChild(lmin); row2.appendChild(lstep); row2.appendChild(lmax);
      card.appendChild(hint);
      sliderListEl.appendChild(card);
    });
  }

  /* ---------- ØªÙØ§Ø¹Ù„ Ø§Ù„Ù…Ø§ÙˆØ³/Ø§Ù„Ø¬ÙˆØ§Ù„ ---------- */
  canvas.addEventListener('mousemove', (e)=>{ const rect=canvas.getBoundingClientRect(), r=devicePixelRatio||1; const sx=(e.clientX-rect.left)*r, sy=(e.clientY-rect.top)*r; const w=screenToWorld(sx,sy);
    state.mouse={x:sx,y:sy,wx:w.x,wy:w.y};
    if(state.dragging){ const dx=(sx-state.dragStart.x)/(state.scale*r), dy=(sy-state.dragStart.y)/(state.scale*r); state.centerX=state.dragStart.cx-dx; state.centerY=state.dragStart.cy+dy; draw(); } else updateStatus();
  });
  canvas.addEventListener('mousedown', ()=>{ state.dragging=true; state.dragStart={x:state.mouse.x,y:state.mouse.y,cx:state.centerX,cy:state.centerY}; });
  window.addEventListener('mouseup', ()=>{ state.dragging=false; persistDeb(); });
  canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); const delta=-Math.sign(e.deltaY); zoomAt(delta>0?1.12:1/1.12, state.mouse.x, state.mouse.y); }, {passive:false});
  canvas.addEventListener('dblclick', ()=>{ resetView(); draw(); persistDeb(); });
  canvas.addEventListener('click', (e)=>{ if(e.altKey){ const w=screenToWorld(state.mouse.x, state.mouse.y); draw(); drawTangentAt(w.x,w.y); } });

  // Ù„Ù…Ø³ Ø§Ù„Ø¬ÙˆØ§Ù„ (Ø³Ø­Ø¨ Ø¨Ø¥ØµØ¨Ø¹ØŒ Ù‚Ø±Øµ Ø¨Ø¥ØµØ¨Ø¹ÙŠÙ†ØŒ Ù†Ù‚Ø±ØªØ§Ù† Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¶Ø¨Ø·)
  canvas.addEventListener('touchstart', (e)=>{
    if(e.touches.length===1){
      const t=e.touches[0], rect=canvas.getBoundingClientRect(), r=devicePixelRatio||1;
      const sx=(t.clientX-rect.left)*r, sy=(t.clientY-rect.top)*r;
      state.touch.active=true; state.touch.fingerCount=1; state.dragging=true; state.dragStart={x:sx,y:sy,cx:state.centerX,cy:state.centerY};
      const now=Date.now(); if(now-state.touch.lastTapTime<300){ resetView(); draw(); persistDeb(); } state.touch.lastTapTime=now;
    }else if(e.touches.length===2){
      state.touch.active=true; state.touch.fingerCount=2; const [a,b]=e.touches; state.touch.lastDist=Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY); state.dragging=false;
    }
  }, {passive:true});
  canvas.addEventListener('touchmove', (e)=>{
    if(!state.touch.active) return;
    if(state.touch.fingerCount===1 && e.touches.length===1){
      const t=e.touches[0], rect=canvas.getBoundingClientRect(), r=devicePixelRatio||1; const sx=(t.clientX-rect.left)*r, sy=(t.clientY-rect.top)*r;
      const dx=(sx-state.dragStart.x)/(state.scale*r), dy=(sy-state.dragStart.y)/(state.scale*r); state.centerX=state.dragStart.cx-dx; state.centerY=state.dragStart.cy+dy; draw();
    }else if(e.touches.length===2){
      const [a,b]=e.touches; const dist=Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY); const factor=dist/(state.touch.lastDist||dist);
      const rect=canvas.getBoundingClientRect(), r=devicePixelRatio||1; const midSx=((a.clientX+b.clientX)/2-rect.left)*r, midSy=((a.clientY+b.clientY)/2-rect.top)*r;
      zoomAt(factor, midSx, midSy); state.touch.lastDist=dist;
    }
  }, {passive:true});
  window.addEventListener('touchend', ()=>{ state.touch.active=false; state.dragging=false; state.touch.fingerCount=0; persistDeb(); }, {passive:true});

  /* ---------- Ø£Ø²Ø±Ø§Ø± Ø¹Ø§Ù…Ø© ---------- */
  document.getElementById('btnDrawer').onclick=()=>{ sidebarEl.classList.toggle('open'); };
  document.getElementById('btnAdd').onclick = ()=>{ state.expressions.push({ id:uid(), color: COLORS[state.expressions.length%COLORS.length], width:2, text:'', visible:true }); renderExprList(); };
  document.getElementById('btnAddSlider').onclick=()=>{ state.sliders.push({ name:`a${state.sliders.length+1}`, min:-5, max:5, step:0.1, value:1 }); renderSliders(); draw(); };
  document.getElementById('btnExport').onclick=()=>{ const url=canvas.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='graph.png'; a.click(); };
  document.getElementById('btnReset').onclick = ()=>{ resetView(); draw(); persistDeb(); };
  document.getElementById('btnZoomIn').onclick = ()=> zoomAt(1.12, state.mouse.x, state.mouse.y);
  document.getElementById('btnZoomOut').onclick= ()=> zoomAt(1/1.12, state.mouse.x, state.mouse.y);
  document.getElementById('btnShare').onclick  = ()=>{ persist(); navigator.clipboard?.writeText(location.href).then(()=>flash('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø·')).catch(()=>flash('Ø§Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· Ù…Ù† Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù†ÙˆØ§Ù†')); };
  document.getElementById('btnSave').onclick   = ()=>{ const blob=new Blob([JSON.stringify(serialize(),null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='graph-settings.json'; a.click(); };
  document.getElementById('btnLoad').onclick   = ()=>{ document.getElementById('fileLoader').click(); };
  document.getElementById('btnTheme').onclick  = ()=>{ const html=document.documentElement; const toLight=!html.classList.contains('light'); [document.documentElement, document.body].forEach(el=>el.classList.toggle('light', toLight)); state.theme=toLight?'light':'dark'; draw(); persistDeb(); };

  /* ---------- Ø­Ø§Ù„Ø©/Ù…Ø´Ø§Ø±ÙƒØ© ---------- */
  function updateStatus(){ statusEl.textContent = `Ø³ = ${toArabicDigits(state.mouse.wx.toFixed(3))}, Øµ = ${toArabicDigits(state.mouse.wy.toFixed(3))} | Ù…Ù‚ÙŠØ§Ø³: 1u â‰ˆ ${Math.round(state.scale)}px`; }
  function flash(msg){ const old=statusEl.textContent; statusEl.textContent=msg; setTimeout(()=>statusEl.textContent=old, 1200); }
  function serialize(){ return { v:6, cx:state.centerX, cy:state.centerY, sc:state.scale, theme:state.theme, expr: state.expressions.map(e=>({t:e.text,c:e.color,w:e.width,v:!!e.visible})), sliders: state.sliders }; }
  function deserialize(o){
    if(!o) return;
    if(typeof o.cx==='number') state.centerX=o.cx;
    if(typeof o.cy==='number') state.centerY=o.cy;
    if(typeof o.sc==='number') state.scale=o.sc;
    const isLight = o.theme==='light'; [document.documentElement, document.body].forEach(el=>el.classList.toggle('light', isLight)); state.theme=isLight?'light':'dark';
    if(Array.isArray(o.expr)) state.expressions=o.expr.map((it,i)=>({ id:uid(), text:it.t||'', color:it.c||COLORS[i%COLORS.length], width: Math.max(0.5, Number(it.w||2)), visible: it.v!==false }));
    if(Array.isArray(o.sliders)) state.sliders=o.sliders;
  }
  function persist(){ const b64=btoa(unescape(encodeURIComponent(JSON.stringify(serialize())))); const url=new URL(location.href); url.hash='#g='+b64; history.replaceState(null,'',url); }
  const persistDeb = debounce(persist, 250);
  function loadFromUrl(){ const m=(location.hash||'').match(/#g=([^&]+)/); if(!m) return false; try{ const obj=JSON.parse(decodeURIComponent(escape(atob(m[1])))); deserialize(obj); return true; }catch(e){ return false; } }
  function debounce(fn,ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); } }

  function resetView(){ state.centerX=0; state.centerY=0; state.scale=60; }
  function showTooltip(sx,sy,msg){ tooltip.style.left=`${sx}px`; tooltip.style.top=`${sy}px`; tooltip.textContent=msg; tooltip.style.display='block'; setTimeout(()=>tooltip.style.display='none', 1800); }
  function zoomAt(factor, sx, sy){ const before=screenToWorld(sx,sy); state.scale=Math.min(1200, Math.max(8, state.scale*factor)); const after=screenToWorld(sx,sy); state.centerX+=(before.x-after.x); state.centerY+=(before.y-after.y); draw(); }

  function init(){
    renderExprList(); renderSliders();
    if(!loadFromUrl()) persist();
    resizeCanvas(); draw();
  }
  init();
})();
</script>
</body>
</html>
