<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ø¢Ù„Ø© Ø±Ø³Ù… Ø¹Ø±Ø¨ÙŠØ© (Ø³/Øµ) â€“ ÙˆØ¶Ø¹ ÙØ§ØªØ­ + ØªØ¨Ø¯ÙŠÙ„</title>
<style>
  /* Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙØ§ØªØ­ (Ø§ÙØªØ±Ø§Ø¶ÙŠ) */
  :root{
    --bg:#ffffff;
    --panel:#f6f7fb;
    --panel-2:#eef1f6;
    --text:#0f172a;
    --muted:#6b7280;
    --grid:#d1d5db;
    --grid-sub:#e5e7eb;
    --axis:#111827;
    --border:#e5e7eb;
    --badge:#eef2ff;
    --accent:#0ea5e9;
  }
  /* Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø§ÙƒÙ† Ø¹Ù†Ø¯ ÙˆØ¬ÙˆØ¯ .dark Ø¹Ù„Ù‰ <html> */
  html.dark{
    --bg:#0b1220;
    --panel:#0f172a;
    --panel-2:#111827;
    --text:#e5e7eb;
    --muted:#9fb2c9;
    --grid:#20314b;
    --grid-sub:#162133;
    --axis:#93c5fd;
    --border:#172133;
    --badge:#0b1422;
    --accent:#22d3ee;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Arabic",Arial;
    overflow:hidden;
  }
  .app{display:grid; grid-template-columns:360px 1fr; height:100%}
  .side{background:linear-gradient(180deg,var(--panel),var(--panel-2)); padding:14px; border-left:1px solid var(--border); overflow:auto}
  .head{display:flex; align-items:center; justify-content:space-between; gap:10px}
  h1{margin:0; font-size:18px}
  .muted{color:var(--muted); font-size:12px; margin-top:4px}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--border); background:var(--badge); font-size:12px; margin-inline:3px 0}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:10px; margin:10px 0}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .btn{background:var(--panel-2); border:1px solid var(--border); color:var(--text); padding:8px 10px; border-radius:10px; cursor:pointer; font-size:13px}
  .btn:hover{filter:brightness(1.04)}
  .input{flex:1; min-width:220px; background:var(--panel-2); border:1px solid var(--border); color:var(--text); border-radius:10px; padding:8px 10px; outline:none}
  .color{width:32px; height:32px; border:0; background:transparent; cursor:pointer}
  .w{width:150px}
  .canvas-wrap{position:relative}
  canvas{display:block; width:100%; height:100%}
  .status{position:absolute; left:10px; bottom:10px; background:rgba(255,255,255,.7); color:#111827; border:1px solid var(--border); border-radius:10px; padding:6px 10px; font-size:12px; backdrop-filter:blur(4px)}
  html.dark .status{background:rgba(2,6,23,.55); color:#cbd5e1}
  @media (max-width:900px){ .app{grid-template-columns:1fr; grid-template-rows:auto 1fr} }
</style>
</head>
<body>
<div class="app">
  <aside class="side">
    <div class="head">
      <div>
        <h1>Ø¢Ù„Ø© Ø±Ø³Ù… (Ø³/Øµ)</h1>
        <div class="muted">
          Ø£Ù…Ø«Ù„Ø©:
          <span class="badge">Ø³ + Øµ = Ù¡</span>
          <span class="badge">Øµ = Ø³^2</span>
          <span class="badge">Ø³*Øµ = Ù¡</span>
        </div>
      </div>
      <button id="toggleTheme" class="btn" title="Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙØ§ØªØ­/Ø§Ù„Ø¯Ø§ÙƒÙ†">ğŸŒ“ ØªØ¨Ø¯ÙŠÙ„</button>
    </div>

    <div id="list"></div>
    <button id="add" class="btn">+ Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø©</button>
  </aside>

  <main class="canvas-wrap">
    <canvas id="cv"></canvas>
    <div id="st" class="status">Ø³=0, Øµ=0</div>
  </main>
</div>

<script>
(() => {
  /* ==================== Ø£Ø¯ÙˆØ§Øª Ø¹Ø±Ø¨ÙŠØ©/ØªÙ†Ø¸ÙŠÙ ==================== */
  const AR = "Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©";
  const EN = "0123456789";
  const toArabic  = s => String(s).replace(/[0-9]/g, d => AR[d]);
  const toEnglish = s => String(s).replace(/[Ù -Ù©]/g, ch => EN[AR.indexOf(ch)]).replace(/ØŒ/g, ',');

  function stripBiDiMarks(s){
    return String(s)
      .replace(/[\u200E\u200F\u061C\u202A-\u202E\u2066-\u2069]/g,'')
      .replace(/[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED]/g,'')
      .replace(/\u0640/g,'');
  }

  const arabicFns = [
    [/\bØ¬Ø§\b/g,'sin'], [/\bØ¬ØªØ§\b/g,'cos'], [/\bØ¸Ø§\b/g,'tan'],
    [/\bØ¬Ø°Ø±\b/g,'sqrt'], [/\bÙ‚ÙŠÙ…Ø©_?Ù…Ø·Ù„Ù‚Ø©\b/g,'abs'],
    [/\bÙ„Ùˆ\b/g,'log'],  [/\bÙ„Ù†\b/g,'log'] // ln -> log
  ];

  function preprocessBasic(s){
    s = stripBiDiMarks(s).replace(/[âˆ’â€“â€”ï¼]/g,'-').replace(/ï¼‹/g,'+');
    s = toEnglish(s);
    s = s.replace(/Ø³/gi,'x').replace(/Øµ/gi,'y')
         .replace(/[xX]/g,'x').replace(/[yY]/g,'y')
         .replace(/[Î¸Ï´]/g,'theta').replace(/Ï€|Ø¨Ø§ÙŠ/gi,'PI').replace(/Ù‡Ù€/g,'E')
         .replace(/[Ã·]/g,'/').replace(/[Ã—]/g,'*').replace(/\^/g,'**');
    arabicFns.forEach(([re,rep])=> s = s.replace(re,rep));
    // Ø¶Ø±Ø¨ Ø¶Ù…Ù†ÙŠ
    const FN='(sin|cos|tan|sqrt|abs|log)';
    s = s.replace(/(\d)\s*(x|y|theta|t|PI|E|\()/gi,'$1*$2')
         .replace(/(x|y|theta|t|PI|E|\))\s*(\d|\()/gi,'$1*$2')
         .replace(new RegExp(`(\\d|x|y|theta|t|PI|E)\\s*${FN}`,'gi'),'$1*$2')
         .replace(new RegExp(`\\)\\s*${FN}`,'gi'),')*$1')
         .replace(/\)\s*\(/g,')*(');
    return s.replace(/\s+/g,' ').trim();
  }

  const sideIsY = raw => /^\(?\s*y\s*\)?$/i.test(preprocessBasic(raw));

  /* ==================== ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª ==================== */
  // Ù†Ù…Ø· Ø«Ø§Ø¨Øª: a*x + b*y = c (Ø¨Ø£ÙŠ ØªØ±ØªÙŠØ¨) -> y = (-ax*x - C)/by
  function parseLinearXY(eqnRaw){
    const s = preprocessBasic(eqnRaw);
    if(!s.includes('=')) return null;
    const [L,R] = s.split('=').map(t=>t.trim());
    function coeffs(expr){
      let t = expr.replace(/-/g,'+-');
      let ax=0, by=0, c=0;
      const terms = t.split('+').map(p=>p.trim()).filter(Boolean);
      for(const term of terms){
        if (/^[+-]?\d*\.?\d*\*?x$/i.test(term) || /^[+-]?x$/i.test(term)){
          const k = term.replace('*','').replace(/x/i,'');
          ax += Number(k===''||k==='+'?1:(k==='-'?-1:k));
        }else if (/^[+-]?\d*\.?\d*\*?y$/i.test(term) || /^[+-]?y$/i.test(term)){
          const k = term.replace('*','').replace(/y/i,'');
          by += Number(k===''||k==='+'?1:(k==='-'?-1:k));
        }else if (/^[+-]?\d+(\.\d+)?$/i.test(term)){
          c += Number(term);
        }else{
          c = NaN; // Ù„ÙŠØ³ Ø®Ø·ÙŠÙ‹Ø§ Ø¨Ø³ÙŠØ·Ù‹Ø§
        }
      }
      return {ax,by,c};
    }
    const A = coeffs(L), B = coeffs(R);
    if(!isFinite(A.c) || !isFinite(B.c)) return null;
    const ax = (A.ax - B.ax);
    const by = (A.by - B.by);
    const C  = (A.c  - B.c );
    if (Math.abs(by) < 1e-12) return null;
    return `(-(${ax})*x - (${C})) / (${by})`;
  }

  /* ==================== Ø±Ø³Ù… ==================== */
  const cv = document.getElementById('cv'); const ctx = cv.getContext('2d');
  const st = document.getElementById('st');
  const list = document.getElementById('list'); const addBtn = document.getElementById('add');
  const toggleThemeBtn = document.getElementById('toggleTheme');

  const COLORS = ['#0ea5e9','#a78bfa','#f472b6','#34d399','#f59e0b','#60a5fa','#ef4444','#10b981'];
  const state = {
    centerX:0, centerY:0, scale:60,
    mouse:{x:0,y:0,wx:0,wy:0},
    exprs:[ {id:rid(), color:COLORS[0], width:2, text:'Ø³ + Øµ = Ù¡', visible:true} ],
    theme: (localStorage.getItem('theme') || 'light') // 'light' | 'dark'
  };

  // Ø·Ø¨Ù‘Ù‚ Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ù…Ø© Ø¹Ù„Ù‰ <html>
  document.documentElement.classList.toggle('dark', state.theme === 'dark');

  // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø³Ù…Ø©
  toggleThemeBtn.onclick = () => {
    state.theme = (state.theme === 'dark') ? 'light' : 'dark';
    document.documentElement.classList.toggle('dark', state.theme === 'dark');
    localStorage.setItem('theme', state.theme);
    draw();
  };

  function rid(){ return Math.random().toString(36).slice(2,9); }
  function worldToScreen(x,y){ const r=devicePixelRatio||1,w=cv.width,h=cv.height; return {x:(w/2)+(x-state.centerX)*state.scale*r, y:(h/2)-(y-state.centerY)*state.scale*r}; }
  function screenToWorld(sx,sy){ const r=devicePixelRatio||1,w=cv.width,h=cv.height; return {x:(sx-w/2)/(state.scale*r)+state.centerX, y:-(sy-h/2)/(state.scale*r)+state.centerY}; }
  function resize(){ const r=devicePixelRatio||1,rect=cv.getBoundingClientRect(); cv.width=Math.max(1,rect.width*r); cv.height=Math.max(1,rect.height*r); draw(); }
  new ResizeObserver(resize).observe(cv.parentElement);

  function niceStep(ppu){ const target=110, units=target/ppu, p=Math.pow(10,Math.floor(Math.log10(units))); const c=[1,2,5,10].map(v=>v*p); return c.reduce((a,b)=>Math.abs(b-units)<Math.abs(a-units)?b:a,c[0]); }

  function drawGrid(){
    const r=devicePixelRatio||1, w=cv.width, h=cv.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle=get('--bg'); ctx.fillRect(0,0,w,h);
    const step=niceStep(state.scale), sub=step/5; const tl=screenToWorld(0,0), br=screenToWorld(w,h);

    // ÙØ±Ø¹ÙŠØ©
    ctx.lineWidth=1; ctx.strokeStyle=get('--grid-sub'); ctx.beginPath();
    for(let x=Math.floor(tl.x/sub)*sub; x<=br.x; x+=sub){ const sx=worldToScreen(x,0).x; ctx.moveTo(sx+.5,0); ctx.lineTo(sx+.5,h); }
    for(let y=Math.floor(br.y/sub)*sub; y<=tl.y; y+=sub){ const sy=worldToScreen(0,y).y; ctx.moveTo(0,sy+.5); ctx.lineTo(w,sy+.5); }
    ctx.stroke();

    // Ø±Ø¦ÙŠØ³ÙŠØ©
    ctx.strokeStyle=get('--grid'); ctx.beginPath();
    for(let x=Math.floor(tl.x/step)*step; x<=br.x; x+=step){ const sx=worldToScreen(x,0).x; ctx.moveTo(sx+.5,0); ctx.lineTo(sx+.5,h); }
    for(let y=Math.floor(br.y/step)*step; y<=tl.y; y+=step){ const sy=worldToScreen(0,y).y; ctx.moveTo(0,sy+.5); ctx.lineTo(w,sy+.5); }
    ctx.stroke();

    // Ù…Ø­Ø§ÙˆØ±
    ctx.strokeStyle=get('--axis'); ctx.lineWidth=1.5; ctx.beginPath();
    const sx0=worldToScreen(0,0).x, sy0=worldToScreen(0,0).y;
    ctx.moveTo(sx0+.5,0); ctx.lineTo(sx0+.5,h);
    ctx.moveTo(0,sy0+.5); ctx.lineTo(w,sy0+.5); ctx.stroke();

    // ØªØ³Ù…ÙŠØ§Øª ÙˆØ£Ø±Ù‚Ø§Ù…
    ctx.fillStyle=get('--axis'); ctx.font=`${12*r}px system-ui,"Noto Sans Arabic",Arial`;
    ctx.textAlign='right'; ctx.textBaseline='top'; ctx.fillText('Ø³', w-8, sy0+6);
    ctx.textAlign='left'; ctx.textBaseline='bottom'; ctx.fillText('Øµ', sx0+6, 14);

    ctx.fillStyle=get('--muted'); ctx.textAlign='right'; ctx.textBaseline='top';
    for(let x=Math.floor(tl.x/step)*step;x<=br.x;x+=step){ if(Math.abs(x)<1e-12)continue; const p=worldToScreen(x,0); ctx.fillText(toArabic(x.toFixed(2).replace(/\.00$/,'')), p.x-4, sy0+6); }
    ctx.textAlign='right'; ctx.textBaseline='bottom';
    for(let y=Math.floor(br.y/step)*step;y<=tl.y;y+=step){ if(Math.abs(y)<1e-12)continue; const p=worldToScreen(0,y); ctx.fillText(toArabic(y.toFixed(2).replace(/\.00$/,'')), sx0-6, p.y-2); }
  }
  function get(name){ return getComputedStyle(document.documentElement).getPropertyValue(name); }

  function adaptiveSampleX(f,L,R){
    const pts=[], maxDepth=12, eps=1e-2, N0=25;
    function rec(a,b,ya,yb,d){ const m=(a+b)/2, ym=f(m);
      if(!isFinite(ya)) ya=f(a); if(!isFinite(yb)) yb=f(b);
      if(!isFinite(ym)||d>=maxDepth){ pts.push([a,ya],[b,yb]); return; }
      const ylin=(ya+yb)/2; if(Math.abs(ym-ylin)<eps*(1+Math.abs(ym))){ pts.push([a,ya],[b,yb]); return; }
      rec(a,m,ya,ym,d+1); rec(m,b,ym,yb,d+1);
    }
    let yL=f(L), yR=f(R);
    if(!isFinite(yL)||!isFinite(yR)){ const dx=(R-L)/N0; let x=L, lx=null, ly=null;
      for(let i=0;i<=N0;i++,x+=dx){ const y=f(x); if(isFinite(y)){ if(lx!==null) rec(lx,x,ly,y,0); lx=x; ly=y; } } }
    else rec(L,R,yL,yR,0);
    pts.sort((a,b)=>a[0]-b[0]); const out=[]; let prev=null; for(const p of pts){ if(!prev||p[0]!==prev[0]) out.push(p); prev=p; } return out;
  }

  function drawCurves(){
    const r=devicePixelRatio||1, w=cv.width;
    const L=screenToWorld(0,0).x, R=screenToWorld(w,0).x;

    for(const [i,ex] of state.exprs.entries()){
      if(!ex.visible) continue;
      const raw = ex.text||''; if(!raw.trim()) continue;
      ctx.strokeStyle = ex.color||COLORS[i%COLORS.length];
      ctx.lineWidth = Math.max(0.5, Number(ex.width||2))*r;

      let js = null, implicit = null;
      if(raw.includes('=')){
        const [lhsRaw, rhsRaw] = raw.split('=');
        if (sideIsY(lhsRaw))      js = preprocessBasic(rhsRaw);
        else if (sideIsY(rhsRaw)) js = preprocessBasic(lhsRaw);
        else {
          const lin = parseLinearXY(raw);
          if (lin) js = lin;
          else {
            const cleaned = preprocessBasic(raw);
            const m = cleaned.match(/^\s*x\s*\*\s*y\s*=\s*([^\s]+)\s*$/i);
            if (m) js = `(${m[1]})/x`;  // Ø³*Øµ=Ø«Ø§Ø¨Øª -> Øµ=Ø«Ø§Ø¨Øª/Ø³
            else implicit = cleaned;     // (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) ÙŠÙ…ÙƒÙ† ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ø¶Ù…Ù†ÙŠ Ù„Ø§Ø­Ù‚Ù‹Ø§
          }
        }
      }else{
        js = preprocessBasic(raw); // Ù†Ø¹ØªØ¨Ø±Ù‡ y = ...
      }

      try{
        if(js){
          const f = Function('x', `with(Math){return (${js});}`);
          const pts = adaptiveSampleX(x => Number(f.call({}, x)), L, R);
          ctx.beginPath(); let pen=false;
          for(const [x,y] of pts){
            const p=worldToScreen(x,y);
            if(!isFinite(p.x)||!isFinite(p.y)){ pen=false; continue; }
            if(!pen){ ctx.moveTo(p.x,p.y); pen=true; } else ctx.lineTo(p.x,p.y);
          }
          ctx.stroke();
        }else if(implicit){
          // ØªØ±Ø³ÙŠÙ… Ø¶Ù…Ù†ÙŠ Ù…Ø¨Ø³Ù‘Ø· (Marching-like Ø®ÙÙŠÙ)
          const F = Function('x','y', `with(Math){return ((${implicit.replace('=','-(')}) )};`);
          const tl=screenToWorld(0,0), br=screenToWorld(cv.width, cv.height);
          const nx=48, ny=32, dx=(br.x-tl.x)/nx, dy=(tl.y-br.y)/ny;
          function val(x,y){ const v=Number(F.call({},x,y)); return isFinite(v)?v:NaN; }
          function lerp(a,b,ta,tb){ const t=ta/(ta-tb); return a+(b-a)*t; }
          for(let iy=0;iy<ny;iy++){
            for(let ix=0;ix<nx;ix++){
              const x0=tl.x+ix*dx, y0=tl.y-iy*dy, x1=x0+dx, y1=y0-dy;
              const v00=val(x0,y0), v10=val(x1,y0), v01=val(x0,y1), v11=val(x1,y1);
              const edges=[];
              if(isFinite(v00)&&isFinite(v10)&&(v00>0)!=(v10>0)) edges.push([lerp(x0,x1,v00,v10), y0]);
              if(isFinite(v10)&&isFinite(v11)&&(v10>0)!=(v11>0)) edges.push([x1, lerp(y0,y1,v10,v11)]);
              if(isFinite(v01)&&isFinite(v11)&&(v01>0)!=(v11>0)) edges.push([lerp(x0,x1,v01,v11), y1]);
              if(isFinite(v00)&&isFinite(v01)&&(v00>0)!=(v01>0)) edges.push([x0, lerp(y0,y1,v00,v01)]);
              if(edges.length===2){
                const p0=worldToScreen(edges[0][0],edges[0][1]), p1=worldToScreen(edges[1][0],edges[1][1]);
                ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
              }
            }
          }
        }
      }catch(e){
        console.warn('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©:', e.message);
      }
    }
  }

  function draw(){ drawGrid(); drawCurves(); st.textContent = `Ø³=${toArabic(state.mouse.wx.toFixed(3))}, Øµ=${toArabic(state.mouse.wy.toFixed(3))}`; }

  /* ==================== ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¯ÙˆØ§Ù„ ==================== */
  function renderList(){
    list.innerHTML='';
    state.exprs.forEach((ex,i)=>{
      const card=document.createElement('div'); card.className='card'; card.dataset.id=ex.id;

      const row1=document.createElement('div'); row1.className='row';
      const col=document.createElement('input'); col.type='color'; col.className='color'; col.value=ex.color||COLORS[i%COLORS.length];
      const inp=document.createElement('input'); inp.className='input'; inp.placeholder='Ù…Ø«Ø§Ù„: Ø³ + Øµ = Ù¡ | Øµ = Ø³^2 | Ø³*Øµ = Ù¡'; inp.value=ex.text||'';
      row1.append(col, inp);

      const row2=document.createElement('div'); row2.className='row';
      const w=document.createElement('input'); w.type='range'; w.min='0.5'; w.max='10'; w.step='0.5'; w.value=ex.width||2; w.className='w';
      const vis=document.createElement('input'); vis.type='checkbox'; vis.checked=ex.visible!==false; const del=document.createElement('button'); del.className='btn'; del.textContent='Ø­Ø°Ù';
      row2.append('Ø³Ù…Ùƒ', w, 'Ø¥Ø¸Ù‡Ø§Ø±', vis, del);

      card.append(row1,row2); list.appendChild(card);

      col.oninput=()=>{ ex.color=col.value; draw(); };
      w.oninput=()=>{ ex.width=parseFloat(w.value)||2; draw(); };
      vis.onchange=()=>{ ex.visible=vis.checked; draw(); };
      del.onclick=()=>{ state.exprs=state.exprs.filter(e=>e.id!==ex.id); renderList(); draw(); };

      // Ø¹Ø±Ø¶ Ø£Ø±Ù‚Ø§Ù… Ø¹Ø±Ø¨ÙŠØ© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ÙƒØªØ§Ø¨Ø© (Ù†Ø®Ø²Ù† Ù†ØµÙ‹Ø§ Ù…Ù†Ø¸Ù‘ÙÙ‹Ø§)
      inp.addEventListener('input', ()=>{
        const start=inp.selectionStart, end=inp.selectionEnd;
        const shown = toArabic(stripBiDiMarks(inp.value));
        inp.value = shown;
        if(start!=null&&end!=null) inp.setSelectionRange(start,end);
        ex.text = stripBiDiMarks(inp.value);
        draw();
      });
    });
  }
  addBtn.onclick=()=>{ state.exprs.push({id:rid(), color:COLORS[state.exprs.length%COLORS.length], width:2, text:'', visible:true}); renderList(); };

  /* ==================== ØªÙØ§Ø¹Ù„ Ø§Ù„Ù„ÙˆØ­Ø© ==================== */
  cv.addEventListener('mousemove',(e)=>{ const r=devicePixelRatio||1, rect=cv.getBoundingClientRect();
    const sx=(e.clientX-rect.left)*r, sy=(e.clientY-rect.top)*r; const w=screenToWorld(sx,sy);
    state.mouse={x:sx,y:sy,wx:w.x,wy:w.y}; st.textContent=`Ø³=${toArabic(w.x.toFixed(3))}, Øµ=${toArabic(w.y.toFixed(3))}`; });

  cv.addEventListener('wheel',(e)=>{ e.preventDefault(); const k=Math.sign(-e.deltaY)>0?1.12:1/1.12;
    const before=screenToWorld(state.mouse.x,state.mouse.y);
    state.scale=Math.min(1200,Math.max(8,state.scale*k));
    const after=screenToWorld(state.mouse.x,state.mouse.y);
    state.centerX+=(before.x-after.x); state.centerY+=(before.y-after.y); draw();
  },{passive:false});

  cv.addEventListener('mousedown', ()=>{
    const start={x:state.mouse.x,y:state.mouse.y,cx:state.centerX,cy:state.centerY};
    function mm(){ const r=devicePixelRatio||1;
      const dx=(state.mouse.x-start.x)/(state.scale*r), dy=(state.mouse.y-start.y)/(state.scale*r);
      state.centerX=start.cx-dx; state.centerY=start.cy+dy; draw(); }
    function up(){ window.removeEventListener('mousemove',mm); window.removeEventListener('mouseup',up); }
    window.addEventListener('mousemove',mm); window.addEventListener('mouseup',up);
  });

  function init(){ renderList(); resize(); draw(); }
  init();
})();
</script>
</body>
</html>
