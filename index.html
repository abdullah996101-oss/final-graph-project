<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>آلة رسم (س/ص) — عربية وبسيطة</title>
<style>
  :root{ --bg:#0b1220; --panel:#0f172a; --text:#e5e7eb; --muted:#9fb2c9;
         --grid:#20314b; --grid-sub:#162133; --axis:#93c5fd; --border:#172133; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);
       font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans Arabic",Arial}
  .app{display:grid;grid-template-columns:360px 1fr;height:100%}
  .side{background:linear-gradient(180deg,var(--panel),#0e1527);padding:14px;border-left:1px solid var(--border);overflow:auto}
  h1{margin:0 0 10px;font-size:18px}
  .muted{color:var(--muted);font-size:12px;margin-bottom:8px}
  .card{background:#0f172a;border:1px solid var(--border);border-radius:12px;padding:10px;margin-bottom:10px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .input{width:100%;background:#111827;border:1px solid var(--border);color:var(--text);
         border-radius:10px;padding:8px 10px;outline:none}
  .btn{background:#111827;border:1px solid var(--border);color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  .btn:hover{filter:brightness(1.08)}
  .color{width:28px;height:28px;border:0;background:transparent;cursor:pointer}
  .w{width:150px}
  .canvas-wrap{position:relative}
  canvas{display:block;width:100%;height:100%}
  .status{position:absolute;left:10px;bottom:10px;background:rgba(2,6,23,.55);
          border:1px solid var(--border);border-radius:10px;padding:6px 10px;font-size:12px;color:#cbd5e1}
  @media (max-width:900px){ .app{grid-template-columns:1fr 1fr;grid-template-rows:auto 1fr}
    .side{grid-column:1/-1} }
</style>
</head>
<body>
<div class="app">
  <aside class="side">
    <h1>آلة رسم (س/ص)</h1>
    <div class="muted">اكتب معادلة بالعربية: <b>ص = س^2</b> أو <b>س + ص = ١</b> أو ضمني <b>س*ص = ١</b>.</div>

    <div id="list"></div>

    <button id="add" class="btn">+ إضافة دالة</button>
  </aside>

  <main class="canvas-wrap">
    <canvas id="cv"></canvas>
    <div id="st" class="status">س=0, ص=0</div>
  </main>
</div>

<script>
(() => {
  // ---------- أدوات عربية ----------
  const AR_DIGITS = "٠١٢٣٤٥٦٧٨٩";
  const EN_DIGITS = "0123456789";
  const toArabic = s => String(s).replace(/[0-9]/g, d => AR_DIGITS[d]);
  const toEnglish = s => String(s).replace(/[٠-٩]/g, ch => EN_DIGITS[AR_DIGITS.indexOf(ch)]).replace(/،/g, ',');

  // إزالة محارف اتجاه/تشكيل/مدّ (قد تُخرب regex)
  function stripBiDiMarks(s){
    return String(s)
      .replace(/[\u200E\u200F\u061C\u202A-\u202E\u2066-\u2069]/g,'')         // BiDi
      .replace(/[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06ED]/g,'')       // تشكيل
      .replace(/\u0640/g,'');                                               // ـ
  }

  // تطبيع أساسي: س->x، ص->y، توحيد الرموز، إدخال ضرب ضمني، ترجمة الدوال
  const arabicPairs = [
    [/\bجا\b/g,'sin'], [/\bجتا\b/g,'cos'], [/\bظا\b/g,'tan'],
    [/\bجذر\b/g,'sqrt'], [/\bقيمة_?مطلقة\b/g,'abs'],
    [/\bلو\b/g,'log'], [/\bلن\b/g,'log'] // ln -> log
  ];
  function preprocessBasic(s){
    s = stripBiDiMarks(s);
    s = s.replace(/[−–—－]/g,'-').replace(/＋/g,'+');  // +/- موحدة
    s = toEnglish(s);
    s = s
      .replace(/س/gi,'x').replace(/ص/gi,'y')          // العربية أولًا
      .replace(/[xX]/g,'x').replace(/[yY]/g,'y')      // توحيد حالة
      .replace(/[θϴ]/g,'theta')
      .replace(/π|باي/gi,'PI').replace(/هـ/g,'E')
      .replace(/[÷]/g,'/').replace(/[×]/g,'*')
      .replace(/\^/g,'**');
    arabicPairs.forEach(([re,rep]) => s = s.replace(re,rep));
    // إدخال الضرب الضمني
    const FN='(sin|cos|tan|sqrt|abs|log)';
    s = s
      .replace(/(\d)\s*(x|y|theta|t|PI|E|\()/gi,'$1*$2')
      .replace(/(x|y|theta|t|PI|E|\))\s*(\d|\()/gi,'$1*$2')
      .replace(new RegExp(`(\\d|x|y|theta|t|PI|E)\\s*${FN}`,'gi'),'$1*$2')
      .replace(new RegExp(`\\)\\s*${FN}`,'gi'),')*$1')
      .replace(/\)\s*\(/g,')*(')
      .replace(/(x|y|theta|t)\s*(PI|E)/gi,'$1*$2')
      .replace(/(PI|E)\s*(x|y|theta|t)/gi,'$1*$2');
    return s.replace(/\s+/g,' ').trim();
  }
  const sideIsY = raw => /^\(?\s*y\s*\)?$/i.test(preprocessBasic(raw).trim());
  const containsY = s => /\by\b/i.test(preprocessBasic(s));

  // محاولة عزل y جبريًا لأنماط شائعة (مرنة للمسافات/الأقواس)
  function stripOuterParens(s){
    s = String(s).trim(); if(!s) return s;
    while(s.startsWith('(') && s.endsWith(')')){
      let d=0, ok=true;
      for(let i=0;i<s.length;i++){ const c=s[i]; if(c==='(') d++; else if(c===')') d--; if(d===0 && i<s.length-1){ ok=false; break; } if(d<0){ ok=false; break; } }
      if(ok) s=s.slice(1,-1).trim(); else break;
    }
    return s;
  }
  function tryLinearSolveForY(lhsRaw, rhsRaw){
    let L0 = stripOuterParens(preprocessBasic(lhsRaw));
    let R0 = stripOuterParens(preprocessBasic(rhsRaw));
    function solve(side, other){
      side  = stripOuterParens(side); other = stripOuterParens(other);
      if (containsY(other)) return null;
      const noY = s => !containsY(s);
      let m;
      // a*y ± b
      m = side.match(/^(?:\((.+?)\)|(.+?))\s*\*?\s*y\s*([+\-])\s*(.+)\s*$/i);
      if(m){ const a=(m[1]??m[2]??'').trim(), op=m[3], b=m[4].trim(); if(noY(a)&&noY(b)) return `(${op==='+'?`(${other})-(${b})`:`(${other})+(${b})`})/(${a})`; }
      // y ± b
      m = side.match(/^\(?\s*y\s*\)?\s*([+\-])\s*(.+)\s*$/i);
      if(m){ const op=m[1], b=m[2].trim(); if(noY(b)) return op==='+'?`(${other})-(${b})`:`(${other})+(${b})`; }
      // a*y
      m = side.match(/^(?:\((.+?)\)|(.+?))\s*\*?\s*y\s*$/i);
      if(m){ const a=(m[1]??m[2]??'').trim(); if(noY(a)) return `(${other})/(${a})`; }
      // y
      if(/^\(?\s*y\s*\)?$/i.test(side)) return `${other}`;
      // other ± y
      m = side.match(/^(.+?)\s*([+\-])\s*\(?\s*y\s*\)?\s*$/i);
      if(m){ const o=stripOuterParens(m[1].trim()), op=m[2]; if(noY(o)) return op==='+'?`(${other})-(${o})`:`(${o})-(${other})`; }
      // other ± (a*y)
      m = side.match(/^(.+?)\s*([+\-])\s*\(?(?:\((.+?)\)|(.+?))\s*\*?\s*y\)?\s*$/i);
      if(m){ const o=stripOuterParens(m[1].trim()), op=m[2], a=stripOuterParens((m[3]??m[4]??'').trim()); if(noY(o)&&noY(a)) return op==='+'?`((${other})-(${o}))/(${a})`:`((${o})-(${other}))/(${a})`; }
      return null;
    }
    let js = solve(R0, L0); if(js) return js;
    js = solve(L0, R0);    if(js) return js;
    return null;
  }

  // تقييم داخل نطاق آمن
  const blocked = /(constructor|prototype|window|document|Function|eval|globalThis)/i;
  const isSafe = e => /^[0-9+\-*/().,\sA-Za-z_]+$/.test(e) && !blocked.test(e);
  function buildScope(vars){
    const S = Object.create(Math); S.PI=Math.PI; S.E=Math.E; S.log10 = v=>Math.log10(v);
    if(vars) Object.assign(S, vars); return S;
  }
  function makeFn1(js){ const code=preprocessBasic(js); if(!code||!isSafe(code)) throw Error('تعبير غير صالح'); return Function('x', `with(this){return (${code});}`).bind(buildScope()); }
  function makeFn2(js){ const code=preprocessBasic(js); if(!code||!isSafe(code)) throw Error('تعبير غير صالح'); return Function('x','y', `with(this){return (${code});}`).bind(buildScope()); }

  // عناصر
  const list = document.getElementById('list');
  const addBtn = document.getElementById('add');
  const cv = document.getElementById('cv'); const ctx = cv.getContext('2d');
  const st = document.getElementById('st');

  const COLORS = ['#22d3ee','#a78bfa','#f472b6','#34d399','#f59e0b','#60a5fa','#ef4444','#10b981'];
  const state = {
    centerX:0, centerY:0, scale:60,
    mouse:{x:0,y:0,wx:0,wy:0},
    exprs:[
      {id:rid(), color:COLORS[0], width:2, text:'ص = س^2', visible:true}
    ]
  };
  function rid(){ return Math.random().toString(36).slice(2,9); }

  // واجهة الدوال
  function renderList(){
    list.innerHTML='';
    state.exprs.forEach((ex,i)=>{
      const card = document.createElement('div'); card.className='card'; card.dataset.id=ex.id;

      const row1 = document.createElement('div'); row1.className='row';
      const col = document.createElement('input'); col.type='color'; col.className='color'; col.value=ex.color;
      const inp = document.createElement('input'); inp.className='input'; inp.placeholder='مثال: س + ص = ١ | ص = س^2 | س*ص = ١'; inp.value=ex.text||'';
      row1.appendChild(col); row1.appendChild(inp);

      const row2 = document.createElement('div'); row2.className='row';
      const w = document.createElement('input'); w.type='range'; w.min='0.5'; w.max='10'; w.step='0.5'; w.value=ex.width||2; w.className='w';
      const vis = document.createElement('input'); vis.type='checkbox'; vis.checked=ex.visible!==false;
      const del = document.createElement('button'); del.className='btn'; del.textContent='حذف';

      row2.append('سمك', w, 'إظهار', vis, del);
      card.append(row1, row2);
      list.appendChild(card);

      col.oninput = ()=>{ ex.color=col.value; draw(); };
      w.oninput   = ()=>{ ex.width=parseFloat(w.value)||2; draw(); };
      vis.onchange= ()=>{ ex.visible=vis.checked; draw(); };
      del.onclick = ()=>{ state.exprs = state.exprs.filter(e=>e.id!==ex.id); renderList(); draw(); };

      // إدخال عربي: أعرض الأرقام بالعربية لكن خزّن كما هي
      inp.addEventListener('input', ()=>{
        const s = inp.value;
        // نُظهر أرقام عربية في الحقل فقط
        const start=inp.selectionStart, end=inp.selectionEnd;
        inp.value = s.replace(/[0-9]/g,d=>AR_DIGITS[d]);
        if(start!=null&&end!=null) inp.setSelectionRange(start,end);

        ex.text = s; // نخزن النص كما كتبه المستخدم
        draw();
      });
    });
  }
  addBtn.onclick = ()=>{ state.exprs.push({id:rid(), color:COLORS[state.exprs.length%COLORS.length], width:2, text:'', visible:true}); renderList(); };

  // تحويلات
  function worldToScreen(x,y){ const r=devicePixelRatio||1,w=cv.width,h=cv.height; return { x:(w/2)+(x-state.centerX)*state.scale*r, y:(h/2)-(y-state.centerY)*state.scale*r }; }
  function screenToWorld(sx,sy){ const r=devicePixelRatio||1,w=cv.width,h=cv.height; return { x:(sx-w/2)/(state.scale*r)+state.centerX, y:-(sy-h/2)/(state.scale*r)+state.centerY }; }
  function resize(){ const r=devicePixelRatio||1, rect=cv.getBoundingClientRect(); cv.width=Math.max(1,rect.width*r); cv.height=Math.max(1,rect.height*r); draw(); }
  new ResizeObserver(resize).observe(cv.parentElement);

  // شبكة
  function niceStep(ppu){ const target=110, units=target/ppu, p=Math.pow(10, Math.floor(Math.log10(units))); const c=[1,2,5,10].map(v=>v*p); let best=c[0]; for(const v of c) if(Math.abs(v-units)<Math.abs(best-units)) best=v; return best; }
  function drawGrid(){
    const r=devicePixelRatio||1, w=cv.width, h=cv.height;
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg'); ctx.fillRect(0,0,w,h);
    const step = niceStep(state.scale), sub=step/5;
    const tl = screenToWorld(0,0), br=screenToWorld(w,h);

    // فرعية
    ctx.lineWidth=1; ctx.strokeStyle=get('--grid-sub'); ctx.beginPath();
    for(let x=Math.floor(tl.x/sub)*sub; x<=br.x; x+=sub){ const sx=worldToScreen(x,0).x; ctx.moveTo(sx+.5,0); ctx.lineTo(sx+.5,h); }
    for(let y=Math.floor(br.y/sub)*sub; y<=tl.y; y+=sub){ const sy=worldToScreen(0,y).y; ctx.moveTo(0,sy+.5); ctx.lineTo(w,sy+.5); }
    ctx.stroke();

    // رئيسية
    ctx.strokeStyle=get('--grid'); ctx.beginPath();
    for(let x=Math.floor(tl.x/step)*step; x<=br.x; x+=step){ const sx=worldToScreen(x,0).x; ctx.moveTo(sx+.5,0); ctx.lineTo(sx+.5,h); }
    for(let y=Math.floor(br.y/step)*step; y<=tl.y; y+=step){ const sy=worldToScreen(0,y).y; ctx.moveTo(0,sy+.5); ctx.lineTo(w,sy+.5); }
    ctx.stroke();

    // محاور
    ctx.strokeStyle=get('--axis'); ctx.lineWidth=1.5; ctx.beginPath();
    const sx0=worldToScreen(0,0).x, sy0=worldToScreen(0,0).y;
    ctx.moveTo(sx0+.5,0); ctx.lineTo(sx0+.5,h);
    ctx.moveTo(0,sy0+.5); ctx.lineTo(w,sy0+.5);
    ctx.stroke();

    // تسميات مختصرة
    ctx.fillStyle=get('--axis'); ctx.font=`${12*r}px system-ui,-apple-system,Segoe UI,Noto Sans Arabic,Arial`;
    ctx.textAlign='right'; ctx.textBaseline='top';    ctx.fillText('س', Math.min(w-6,w-6), sy0+6);
    ctx.textAlign='left';  ctx.textBaseline='bottom'; ctx.fillText('ص', sx0+6, Math.max(12,12));

    // أرقام
    ctx.fillStyle=get('--muted'); ctx.textAlign='right'; ctx.textBaseline='top';
    for(let x=Math.floor(tl.x/step)*step; x<=br.x; x+=step){ if(Math.abs(x)<1e-12) continue; const p=worldToScreen(x,0); ctx.fillText(toArabic(x.toFixed(2).replace(/\.00$/,'')), p.x-4, sy0+6); }
    ctx.textAlign='right'; ctx.textBaseline='bottom';
    for(let y=Math.floor(br.y/step)*step; y<=tl.y; y+=step){ if(Math.abs(y)<1e-12) continue; const p=worldToScreen(0,y); ctx.fillText(toArabic(y.toFixed(2).replace(/\.00$/,'')), sx0-6, p.y-2); }
  }
  function get(varName){ return getComputedStyle(document.documentElement).getPropertyValue(varName); }

  // أخذ عينات تكيفي y=f(x)
  function adaptiveSampleX(f,L,R){
    const pts=[], maxDepth=12, eps=1e-2, N0=25;
    function rec(a,b,ya,yb,d){
      const m=(a+b)/2, ym=f(m);
      if(!isFinite(ya)) ya=f(a); if(!isFinite(yb)) yb=f(b);
      if(!isFinite(ym)||d>=maxDepth){ pts.push([a,ya],[b,yb]); return; }
      const ylin=(ya+yb)/2; if(Math.abs(ym-ylin)<eps*(1+Math.abs(ym))){ pts.push([a,ya],[b,yb]); return; }
      rec(a,m,ya,ym,d+1); rec(m,b,ym,yb,d+1);
    }
    let yL=f(L), yR=f(R);
    if(!isFinite(yL)||!isFinite(yR)){
      const dx=(R-L)/N0; let x=L, lx=null, ly=null;
      for(let i=0;i<=N0;i++,x+=dx){ const y=f(x); if(isFinite(y)){ if(lx!==null) rec(lx,x,ly,y,0); lx=x; ly=y; } }
    } else rec(L,R,yL,yR,0);
    pts.sort((a,b)=>a[0]-b[0]); const out=[]; let prev=null; for(const p of pts){ if(!prev || p[0]!==prev[0]) out.push(p); prev=p; } return out;
  }

  // رسم جميع الدوال
  function drawCurves(){
    const r=devicePixelRatio||1, w=cv.width;
    const viewL=screenToWorld(0,0).x, viewR=screenToWorld(w,0).x;

    for(const [i,ex] of state.exprs.entries()){
      if(!ex.visible) continue;
      ctx.strokeStyle = ex.color || COLORS[i%COLORS.length];
      ctx.lineWidth = Math.max(0.5, Number(ex.width||2)) * r;

      const raw = ex.text || '';
      const s = raw.trim();
      if(!s) continue;

      // حدد النوع (صريح/ضمني)
      let kind='explicit', js='', eq='';
      if (s.includes('=')){
        // لو كان ص=... مباشرة
        const [lhs, rhs] = s.split('=');
        if (sideIsY(lhs)) { kind='explicit'; js = preprocessBasic(rhs); }
        else if (sideIsY(rhs)) { kind='explicit'; js = preprocessBasic(lhs); }
        else{
          // حاول العزل الخطي
          const solved = tryLinearSolveForY(lhs, rhs);
          if (solved) { kind='explicit'; js = preprocessBasic(solved); }
          else { kind='implicit'; eq = preprocessBasic(s); }
        }
      } else {
        kind='explicit'; js = preprocessBasic(s);
      }

      try{
        if(kind==='explicit'){
          const f = makeFn1(js);
          const pts = adaptiveSampleX(f, viewL, viewR);
          ctx.beginPath(); let pen=false;
          for(const [x,y] of pts){ const p=worldToScreen(x,y);
            if(!isFinite(p.x)||!isFinite(p.y)){ pen=false; continue; }
            if(!pen){ ctx.moveTo(p.x,p.y); pen=true; } else ctx.lineTo(p.x,p.y);
          }
          ctx.stroke();
        }else{
          // ضمني: F(x,y)=0 + محاولة عزل عددي y(x) إن كانت خطية في y
          const F = (()=>{ const e = eq.replace('=','-(')+')'; return makeFn2(e); })();
          function yFromLinear(x){
            const b=F(x,0); const a=F(x,1)-b;
            if(!isFinite(a)||Math.abs(a)<1e-9) return NaN;
            const y=-b/a, res=Math.abs(F(x,y));
            return (isFinite(y)&&res<=1e-3*(1+Math.abs(y)))?y:NaN;
          }
          const ptsE = adaptiveSampleX(yFromLinear, viewL, viewR);
          if (ptsE.length >= 2){
            ctx.beginPath(); let pen=false;
            for(const [x,y] of ptsE){ const p=worldToScreen(x,y);
              if(!isFinite(p.x)||!isFinite(p.y)){ pen=false; continue; }
              if(!pen){ ctx.moveTo(p.x,p.y); pen=true; } else ctx.lineTo(p.x,p.y);
            }
            ctx.stroke();
          }else{
            // Marching squares مبسّط
            const tl=screenToWorld(0,0), br=screenToWorld(cv.width, cv.height);
            const nx=60, ny=40, dx=(br.x-tl.x)/nx, dy=(tl.y-br.y)/ny;
            function val(x,y){ const v=F(x,y); return isFinite(v)?v:NaN; }
            function lerp(a,b,ta,tb){ const t=ta/(ta-tb); return a+(b-a)*t; }
            for(let iy=0;iy<ny;iy++){
              for(let ix=0;ix<nx;ix++){
                const x0=tl.x+ix*dx, y0=tl.y-iy*dy, x1=x0+dx, y1=y0-dy;
                const v00=val(x0,y0), v10=val(x1,y0), v01=val(x0,y1), v11=val(x1,y1);
                const edges=[];
                if(isFinite(v00)&&isFinite(v10)&&(v00>0)!=(v10>0)) edges.push([lerp(x0,x1,v00,v10), y0]);
                if(isFinite(v10)&&isFinite(v11)&&(v10>0)!=(v11>0)) edges.push([x1, lerp(y0,y1,v10,v11)]);
                if(isFinite(v01)&&isFinite(v11)&&(v01>0)!=(v11>0)) edges.push([lerp(x0,x1,v01,v11), y1]);
                if(isFinite(v00)&&isFinite(v01)&&(v00>0)!=(v01>0)) edges.push([x0, lerp(y0,y1,v00,v01)]);
                if(edges.length===2){
                  const p0=worldToScreen(edges[0][0],edges[0][1]), p1=worldToScreen(edges[1][0],edges[1][1]);
                  ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke();
                }
              }
            }
          }
        }
      }catch(e){
        // لو حصل خطأ، لا نوقف الرسم لكل شيء
        console.warn('Expr error:', e.message);
      }
    }
  }

  function draw(){ drawGrid(); drawCurves(); st.textContent = `س=${toArabic(state.mouse.wx.toFixed(3))}, ص=${toArabic(state.mouse.wy.toFixed(3))}`; }

  // أحداث تفاعل
  cv.addEventListener('mousemove', (e)=>{
    const r=devicePixelRatio||1, rect=cv.getBoundingClientRect();
    const sx=(e.clientX-rect.left)*r, sy=(e.clientY-rect.top)*r;
    const w=screenToWorld(sx,sy); state.mouse={x:sx,y:sy,wx:w.x,wy:w.y}; st.textContent=`س=${toArabic(w.x.toFixed(3))}, ص=${toArabic(w.y.toFixed(3))}`;
  });
  cv.addEventListener('wheel', (e)=>{ e.preventDefault(); const k = Math.sign(-e.deltaY)>0 ? 1.12 : 1/1.12;
    const before=screenToWorld(state.mouse.x,state.mouse.y);
    state.scale=Math.min(1200, Math.max(8, state.scale*k));
    const after =screenToWorld(state.mouse.x,state.mouse.y);
    state.centerX += (before.x-after.x); state.centerY += (before.y-after.y); draw();
  }, {passive:false});
  cv.addEventListener('mousedown', ()=>{
    const start={x:state.mouse.x,y:state.mouse.y,cx:state.centerX,cy:state.centerY};
    function mm(ev){ const r=devicePixelRatio||1; const dx=(state.mouse.x-start.x)/(state.scale*r), dy=(state.mouse.y-start.y)/(state.scale*r);
      state.centerX=start.cx-dx; state.centerY=start.cy+dy; draw(); }
    function up(){ window.removeEventListener('mousemove', mm); window.removeEventListener('mouseup', up); }
    window.addEventListener('mousemove', mm); window.addEventListener('mouseup', up);
  });

  // بدء
  function init(){ renderList(); resize(); draw(); }
  init();
})();
</script>
</body>
</html>
